//// Created by bugra on 15/11/2020.//#ifndef ASSIGNMENT1_GAME_H#define ASSIGNMENT1_GAME_H#include "Card.h"#include "IO.h"class Game {public:    static Stack tableau[7];    static Stack stock;    static Stack waste;    static Stack foundation[4];    static int wasteOpen;    static void dealCards(Stack deck) {        int k = 0;        for (int i = 0; i <= 7; i++) { // Vertical            for (int j = i; j < 7; j++) { // Horizontal                tableau[j].push(deck.pop());            }        }        for (int l = 0; l < 7; l++) { // Open every top card            tableau[l].data[tableau[l].top].isOpen = true;        }        stock = deck; // Make the stock a copy of remaining deck        Card temp;    }    static void openStock() {        wasteOpen = 0;        if (stock.top >= 0) { // Check which command we will apply (fill stock or fill waste)            for (int i = 0; i < 3; i++) {                if (stock.top >= 0) { // Check if the stock has another card for every step. Dont draw a card if not.                    stock.data[stock.top].isOpen = true;                    waste.push(stock.pop());                    ++wasteOpen;                }            }        } else {            while (waste.top >= 0) {                stock.push(waste.pop());            }        }    }    static int decideColor(int i) {        int color;        if (i == 0 || i == 1) {            color = 0;        } else {            color = 1;        }        return color;    }    static bool canStack(Card card1, Card card2) { // True if the two cards can be stacked card1 over card2 (IN TABLEAU)        return (decideColor(card1.getSuit()) != decideColor(card2.getSuit())) &&                (card1.getNumber() + 1 == card2.getNumber());    }    static bool isAStack(int topIndex, Stack stack, std::string fileName) {        bool flag = true;        if (!stack.isEmpty() && stack.top > topIndex) { // If the stack has more than that many elements            for (int i = 0; i <= topIndex; i++) {                if (i != topIndex) {                    flag = flag && canStack(stack.data[stack.top - i], stack.data[stack.top - i - 1]);                }            }        } else if (!stack.isEmpty() && stack.top == 0) {            flag = true;        } else {            writeToFile(fileName, "Invalid Move!", true);        }        return flag;    }    // True if moved card number is one less than top card of target stack and their colors are different.    static bool isValidMove(Card card, Stack stack) {        return (stack.isEmpty() && card.getNumber() == 13) || ((!stack.isEmpty() && card.getNumber() == stack.topElem().getNumber() - 1) &&        (decideColor(card.getSuit()) != decideColor(stack.topElem().getSuit())));    }    // True if moved card number is one more than top card of target stack and their colors are same.    static bool isValidFoundation(Card card, Stack stack) {        return (stack.isEmpty() && card.getNumber() == 01) || ((card.getNumber() == stack.topElem().getNumber() + 1) &&        (card.getSuit() == stack.topElem().getSuit()));    }    static void moveToFoundation(std::string cmd, int pileNum, std::string fileName) {        if (cmd == "pile") {            if (!tableau[pileNum].isEmpty() ) {                Card card = tableau[pileNum].topElem();                if (isValidFoundation(card, foundation[card.getSuit()])) {                    foundation[card.getSuit()].push(tableau[pileNum].pop());                }            } else {                writeToFile(fileName, "Invalid Move!", true);            }        } else if (cmd == "waste") {            if (!waste.isEmpty()) {                Card card = waste.data[waste.top];                if (isValidFoundation(card, foundation[card.getSuit()])) {                    foundation[card.getSuit()].push(waste.pop());                    wasteOpen--;                    if ((wasteOpen == 0) && !waste.isEmpty()) {                        wasteOpen = 1;                    }                }            } else {                writeToFile(fileName, "Invalid Move!", true);            }        }    }    static void move(std::string cmd, int sourcePile, int sourceIndex, int destPile, std::string fileName) {        if (cmd == "pile" && isAStack(sourceIndex, tableau[sourcePile], fileName) &&        isValidMove(tableau[sourcePile].topIndexElem(sourceIndex), tableau[destPile])) {            //canStack(tableau[destPile].topElem(), tableau[sourcePile].topIndexElem(sourceIndex))            Stack temp;            for (int i = 0; i <= sourceIndex; i++) {                temp.push(tableau[sourcePile].pop());            }            for (int i = 0; i <= sourceIndex; i++) {                tableau[destPile].push(temp.pop());            }        } else if (cmd == "waste" && !waste.isEmpty() &&        isValidMove(waste.topElem(), tableau[destPile])) {            tableau[destPile].push(waste.pop());            wasteOpen--;            if ((wasteOpen == 0) && !waste.isEmpty()) {                wasteOpen = 1;            }        } else if (cmd == "foundation" && !foundation[sourcePile].isEmpty() &&        isValidMove(foundation[sourcePile].topElem(), tableau[destPile])) {            tableau[destPile].push(foundation[sourcePile].pop());        } else {            writeToFile(fileName, "Invalid Move! : Cannot move", true);        }    }    static void open (int pile, std::string fileName) {        if (!tableau[pile].topElem().isOpen) {            tableau[pile].data[tableau[pile].top].isOpen = true;        } else {            writeToFile(fileName, "The topmost card is already open!", true);        }    }    static void exit (std::string fileName) {        writeToFile(fileName, "Game Over!", true);        std::exit(0);    }};#endif //ASSIGNMENT1_GAME_H